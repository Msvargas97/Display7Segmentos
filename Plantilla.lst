CCS PCH C Compiler, Version 4.120, 5729               11-dic.-15 22:33

               Filename: M:\PIC Projects\Display7Segmentos\Plantilla.lst

               ROM used: 5292 bytes (4%)
                         Largest free fragment is 65528
               RAM used: 66 (2%) at main() level
                         95 (3%) worst case
               Stack:    3 worst case (2 in main + 1 for interrupts)

*
01000:  GOTO   23A8
*
01008:  MOVWF  04
0100A:  MOVFF  FD8,05
0100E:  MOVFF  FE0,06
01012:  MOVLB  0
01014:  MOVFF  FE9,0C
01018:  MOVFF  FEA,07
0101C:  MOVFF  FE1,08
01020:  MOVFF  FE2,09
01024:  MOVFF  FD9,0A
01028:  MOVFF  FDA,0B
0102C:  MOVFF  FF3,12
01030:  MOVFF  FF4,13
01034:  MOVFF  FFA,14
01038:  MOVFF  FF5,15
0103C:  MOVFF  FF6,16
01040:  MOVFF  FF7,17
01044:  MOVFF  FF8,18
01048:  MOVFF  FFB,19
0104C:  MOVFF  00,0E
01050:  MOVFF  01,0F
01054:  MOVFF  02,10
01058:  MOVFF  03,11
0105C:  BTFSS  FF2.5
0105E:  GOTO   1068
01062:  BTFSC  FF2.2
01064:  GOTO   1134
01068:  MOVFF  0E,00
0106C:  MOVFF  0F,01
01070:  MOVFF  10,02
01074:  MOVFF  11,03
01078:  MOVFF  0C,FE9
0107C:  MOVFF  07,FEA
01080:  BSF    07.7
01082:  MOVFF  08,FE1
01086:  MOVFF  09,FE2
0108A:  MOVFF  0A,FD9
0108E:  MOVFF  0B,FDA
01092:  MOVFF  12,FF3
01096:  MOVFF  13,FF4
0109A:  MOVFF  14,FFA
0109E:  MOVFF  15,FF5
010A2:  MOVFF  16,FF6
010A6:  MOVFF  17,FF7
010AA:  MOVFF  18,FF8
010AE:  MOVFF  19,FFB
010B2:  MOVF   04,W
010B4:  MOVFF  06,FE0
010B8:  MOVFF  05,FD8
010BC:  RETFIE 0
.................... #include "EMm47J53_StackConfig.h" 
.................... /* 
.................... ** ########################################################################## 
.................... **     Filename  : EMm47J53_StackConfig.h 
.................... **     Processor : PIC18F47J53 
.................... **     FileFormat: V1.00 
.................... **     DataSheet : PIC18F47J53 
.................... **     Compiler  : CCS Compiler V4.114 
.................... **     Date/Time : 14.12.2011, 11:00 
.................... ** 
.................... ** 
.................... ** 
.................... ** 
.................... **     (c) Copyright OCTOPLUS.2008-2011 
.................... **     OCTOPLUS.  
.................... **     Ernesto Andres Rincon Cruz 
.................... **     Republica de Colombia 
.................... **     http      : www.octoplusaz.com 
.................... **     mail      : soporte@octoplusaz.com 
.................... **  
.................... ** 
.................... **     Nota:  Todas las funciones estan debidamente probadas usando el  
.................... **            modulo EMm47J53 corriendo a una frecuencia de bus interno  
.................... **            de 12MHz. Para mas informacion www.octoplusaz.com/foros 
.................... ** ########################################################################### 
.................... */ 
.................... #ifndef _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #define _INC_OCTOPLUS_STACK_CONFIG_H 
.................... #include <18F47J53.h> 
.................... //////// Standard Header file for the PIC18F47J53 device //////////////// 
.................... #device PIC18F47J53 
.................... #list 
....................  
....................  
....................  
.................... #device ADC=8 
....................  
.................... #FUSES NOWDT         //WDT disabled (enabled by SWDTEN bit)                     
.................... #FUSES PLL3          //Divide by 3 (12 MHz oscillator input)             
.................... #FUSES NOPLLEN       //PLL Disabled 
.................... #FUSES NOSTVREN      //stack overflow/underflow reset enabled                 
.................... #FUSES NOXINST       //Extended instruction set disabled             
.................... #FUSES NOCPUDIV      //No CPU system clock divide          
.................... #FUSES NOPROTECT     //Program memory is not code-protected           
.................... #FUSES HSPLL         //HS oscillator, PLL enabled, HSPLL used by USB            
.................... #FUSES SOSC_HIGH     //High Power T1OSC/SOSC circuit selected 
.................... #FUSES CLOCKOUT      //CLKO output enabled on the RA6 pin  
.................... #FUSES NOFCMEN       //Fail-Safe Clock Monitor disabled 
.................... #FUSES NOIESO        //Two-Speed Start-up disabled 
.................... #FUSES WDT32768      //Watchdog Postscaler 1:32768 
.................... #FUSES DSWDTOSC_INT  //DSWDT uses INTOSC/INTRC as clock 
.................... #FUSES RTCOSC_INT    //RTCC uses INTRC as clock 
.................... #FUSES NODSBOR       //Zero-Power BOR disabled in Deep Sleep 
.................... #FUSES NODSWDT       //Deep Sleep Watchdog Timer Disabled 
.................... #FUSES DSWDT8192     //Deep Sleep Watchdog Postscaler: 1:8,192 (8.5 seconds)    
.................... #FUSES NOIOL1WAY     //IOLOCK bit can be set and cleared 
.................... #FUSES ADC12         //ADC 10 or 12 Bit Select:12 - Bit ADC Enabed  
.................... #FUSES MSSPMSK7      //MSSP 7 Bit address masking 
.................... #FUSES NOWPFP        //Write Protect Program Flash Page 0 
.................... #FUSES NOWPCFG       //Write/Erase last page protect Disabled 
.................... #FUSES WPDIS         //WPFP[5:0], WPEND, and WPCFG bits ignored  
.................... #FUSES WPEND         //Start protection at page 0 
.................... #FUSES LS48MHZ       //Low Speed USB mode with 48 MHz System clock at 48 MHz USB CLKEN divide-by is set to 8  
.................... #use delay(clock=48000000) 
018C2:  CLRF   FEA
018C4:  MOVLW  49
018C6:  MOVWF  FE9
018C8:  MOVF   FEF,W
018CA:  BZ    18E8
018CC:  MOVLW  0F
018CE:  MOVWF  01
018D0:  CLRF   00
018D2:  DECFSZ 00,F
018D4:  BRA    18D2
018D6:  DECFSZ 01,F
018D8:  BRA    18D0
018DA:  MOVLW  8F
018DC:  MOVWF  00
018DE:  DECFSZ 00,F
018E0:  BRA    18DE
018E2:  NOP   
018E4:  DECFSZ FEF,F
018E6:  BRA    18CC
018E8:  RETURN 0
....................  
.................... #pin_select U2TX=PIN_D2 //Selecciona hardware UART2 
.................... #pin_select U2RX=PIN_D3 //Selecciona hardware UART2 
....................  
....................  
.................... #define LOADER_END   0xFFF                         
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9)   //Protege posiciones de memoria desde la 0x0000 hasta la 0x1000    
.................... #org 0, LOADER_END {} 
....................  
.................... #bit PLLEN = 0xf9b.6 
....................  
.................... // Plantilla modificada por Michael Vargas 
.................... // Derechos de autor a Octoplus y PIC CCS 
....................  
.................... // # 06/12/2015 ---> 15 funciones añadidas  
.................... // # 06/12/2015 ---> timer0 preconfigurado para crear diferentes timers usando la funcion millis() y micros() 
....................  
.................... #define HIGH 0x01 
.................... #define LOW 0x02 
.................... #define min(a,b) ((a)<(b)?(a):(b)) 
.................... #define max(a,b) ((a)>(b)?(a):(b)) 
.................... #define abs(x) ((x)>0?(x):-(x)) 
.................... #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt))) 
.................... #define round(x)     ((x)>=0?(LONG)((x)+0.5):(long)((x)-0.5)) 
.................... #define lowByte(w) ((uint8_t) ((w) & 0xff)) 
.................... #define highByte(w) ((uint8_t) ((w) >> 8)) 
.................... #define bitRead(value, bit) (((value) >> (bit)) & 0x01) 
.................... #define bitSet(value, bit) ((value) |= (1UL << (bit))) 
.................... #define bitClear(value, bit) ((value) &= ~(1UL << (bit))) 
.................... #define bitWrite(value, bit, bitvalue) (bitvalue ? bitSet(value, bit) : bitClear(value, bit)) 
....................  
.................... int16 map(INT16 x, int16 in_min, int16 in_max, int16 out_min, int16 out_max) 
.................... { 
....................    return(x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; 
.................... } 
.................... void digitalWrite(int16 pin,int1 state){ 
.................... if(state){output_high(pin);} 
.................... else{output_low(pin);} 
.................... } 
.................... volatile unsigned int32 timer0_overflow_count;  
....................  
.................... unsigned int32 micros(){; 
.................... return (timer0_overflow_count*1000); 
.................... } 
....................  
.................... unsigned int32 millis(void){ 
.................... static unsigned int32 m; 
.................... disable_interrupts(INT_TIMER0); 
.................... m=timer0_overflow_count; 
.................... enable_interrupts(INT_TIMER0); 
.................... return m; 
.................... } 
....................  
.................... #INT_TIMER0 
.................... void TIMER0_isr() 
.................... { 
....................    timer0_overflow_count++;  
*
01134:  MOVLW  01
01136:  ADDWF  1B,F
01138:  BTFSC  FD8.0
0113A:  INCF   1C,F
0113C:  BTFSC  FD8.2
0113E:  INCF   1D,F
01140:  BTFSC  FD8.2
01142:  INCF   1E,F
....................    set_timer0(62536);  
01144:  MOVLW  F4
01146:  MOVWF  FD7
01148:  MOVLW  48
0114A:  MOVWF  FD6
.................... } 
....................  
.................... #define mcu_init()\ 
.................... do{\ 
....................  PLLEN = 1;        /*Habilita PLL para generar 48MHz de oscilador*/\ 
....................   setup_timer_0(RTCC_INTERNAL|RTCC_DIV_4); \  
....................   set_timer0(62536);  \  
....................   enable_interrupts(INT_TIMER0); \  
.................... }while(0) 
....................  
.................... // binary de Arduino 
.................... #define B0 0 
.................... #define B00 0 
.................... #define B000 0 
.................... #define B0000 0 
.................... #define B00000 0 
.................... #define B000000 0 
.................... #define B0000000 0 
.................... #define B00000000 0 
.................... #define B1 1 
.................... #define B01 1 
.................... #define B001 1 
.................... #define B0001 1 
.................... #define B00001 1 
.................... #define B000001 1 
.................... #define B0000001 1 
.................... #define B00000001 1 
.................... #define B10 2 
.................... #define B010 2 
.................... #define B0010 2 
.................... #define B00010 2 
.................... #define B000010 2 
.................... #define B0000010 2 
.................... #define B00000010 2 
.................... #define B11 3 
.................... #define B011 3 
.................... #define B0011 3 
.................... #define B00011 3 
.................... #define B000011 3 
.................... #define B0000011 3 
.................... #define B00000011 3 
.................... #define B100 4 
.................... #define B0100 4 
.................... #define B00100 4 
.................... #define B000100 4 
.................... #define B0000100 4 
.................... #define B00000100 4 
.................... #define B101 5 
.................... #define B0101 5 
.................... #define B00101 5 
.................... #define B000101 5 
.................... #define B0000101 5 
.................... #define B00000101 5 
.................... #define B110 6 
.................... #define B0110 6 
.................... #define B00110 6 
.................... #define B000110 6 
.................... #define B0000110 6 
.................... #define B00000110 6 
.................... #define B111 7 
.................... #define B0111 7 
.................... #define B00111 7 
.................... #define B000111 7 
.................... #define B0000111 7 
.................... #define B00000111 7 
.................... #define B1000 8 
.................... #define B01000 8 
.................... #define B001000 8 
.................... #define B0001000 8 
.................... #define B00001000 8 
.................... #define B1001 9 
.................... #define B01001 9 
.................... #define B001001 9 
.................... #define B0001001 9 
.................... #define B00001001 9 
.................... #define B1010 10 
.................... #define B01010 10 
.................... #define B001010 10 
.................... #define B0001010 10 
.................... #define B00001010 10 
.................... #define B1011 11 
.................... #define B01011 11 
.................... #define B001011 11 
.................... #define B0001011 11 
.................... #define B00001011 11 
.................... #define B1100 12 
.................... #define B01100 12 
.................... #define B001100 12 
.................... #define B0001100 12 
.................... #define B00001100 12 
.................... #define B1101 13 
.................... #define B01101 13 
.................... #define B001101 13 
.................... #define B0001101 13 
.................... #define B00001101 13 
.................... #define B1110 14 
.................... #define B01110 14 
.................... #define B001110 14 
.................... #define B0001110 14 
.................... #define B00001110 14 
.................... #define B1111 15 
.................... #define B01111 15 
.................... #define B001111 15 
.................... #define B0001111 15 
.................... #define B00001111 15 
.................... #define B10000 16 
.................... #define B010000 16 
.................... #define B0010000 16 
.................... #define B00010000 16 
.................... #define B10001 17 
.................... #define B010001 17 
.................... #define B0010001 17 
.................... #define B00010001 17 
.................... #define B10010 18 
.................... #define B010010 18 
.................... #define B0010010 18 
.................... #define B00010010 18 
.................... #define B10011 19 
.................... #define B010011 19 
.................... #define B0010011 19 
.................... #define B00010011 19 
.................... #define B10100 20 
.................... #define B010100 20 
.................... #define B0010100 20 
.................... #define B00010100 20 
.................... #define B10101 21 
.................... #define B010101 21 
.................... #define B0010101 21 
.................... #define B00010101 21 
.................... #define B10110 22 
.................... #define B010110 22 
.................... #define B0010110 22 
.................... #define B00010110 22 
.................... #define B10111 23 
.................... #define B010111 23 
.................... #define B0010111 23 
.................... #define B00010111 23 
.................... #define B11000 24 
.................... #define B011000 24 
.................... #define B0011000 24 
.................... #define B00011000 24 
.................... #define B11001 25 
.................... #define B011001 25 
.................... #define B0011001 25 
.................... #define B00011001 25 
.................... #define B11010 26 
.................... #define B011010 26 
.................... #define B0011010 26 
.................... #define B00011010 26 
.................... #define B11011 27 
.................... #define B011011 27 
.................... #define B0011011 27 
.................... #define B00011011 27 
.................... #define B11100 28 
.................... #define B011100 28 
.................... #define B0011100 28 
.................... #define B00011100 28 
.................... #define B11101 29 
.................... #define B011101 29 
.................... #define B0011101 29 
.................... #define B00011101 29 
.................... #define B11110 30 
.................... #define B011110 30 
.................... #define B0011110 30 
.................... #define B00011110 30 
.................... #define B11111 31 
.................... #define B011111 31 
.................... #define B0011111 31 
.................... #define B00011111 31 
.................... #define B100000 32 
.................... #define B0100000 32 
.................... #define B00100000 32 
.................... #define B100001 33 
.................... #define B0100001 33 
.................... #define B00100001 33 
.................... #define B100010 34 
.................... #define B0100010 34 
.................... #define B00100010 34 
.................... #define B100011 35 
.................... #define B0100011 35 
.................... #define B00100011 35 
.................... #define B100100 36 
.................... #define B0100100 36 
.................... #define B00100100 36 
.................... #define B100101 37 
.................... #define B0100101 37 
.................... #define B00100101 37 
.................... #define B100110 38 
.................... #define B0100110 38 
.................... #define B00100110 38 
.................... #define B100111 39 
.................... #define B0100111 39 
.................... #define B00100111 39 
.................... #define B101000 40 
.................... #define B0101000 40 
.................... #define B00101000 40 
.................... #define B101001 41 
.................... #define B0101001 41 
.................... #define B00101001 41 
.................... #define B101010 42 
.................... #define B0101010 42 
.................... #define B00101010 42 
.................... #define B101011 43 
.................... #define B0101011 43 
.................... #define B00101011 43 
.................... #define B101100 44 
.................... #define B0101100 44 
.................... #define B00101100 44 
.................... #define B101101 45 
.................... #define B0101101 45 
.................... #define B00101101 45 
.................... #define B101110 46 
.................... #define B0101110 46 
.................... #define B00101110 46 
.................... #define B101111 47 
.................... #define B0101111 47 
.................... #define B00101111 47 
.................... #define B110000 48 
.................... #define B0110000 48 
.................... #define B00110000 48 
.................... #define B110001 49 
.................... #define B0110001 49 
.................... #define B00110001 49 
.................... #define B110010 50 
.................... #define B0110010 50 
.................... #define B00110010 50 
.................... #define B110011 51 
.................... #define B0110011 51 
.................... #define B00110011 51 
.................... #define B110100 52 
.................... #define B0110100 52 
.................... #define B00110100 52 
.................... #define B110101 53 
.................... #define B0110101 53 
.................... #define B00110101 53 
.................... #define B110110 54 
.................... #define B0110110 54 
.................... #define B00110110 54 
.................... #define B110111 55 
.................... #define B0110111 55 
.................... #define B00110111 55 
.................... #define B111000 56 
.................... #define B0111000 56 
.................... #define B00111000 56 
.................... #define B111001 57 
.................... #define B0111001 57 
.................... #define B00111001 57 
.................... #define B111010 58 
.................... #define B0111010 58 
.................... #define B00111010 58 
.................... #define B111011 59 
.................... #define B0111011 59 
.................... #define B00111011 59 
.................... #define B111100 60 
.................... #define B0111100 60 
.................... #define B00111100 60 
.................... #define B111101 61 
.................... #define B0111101 61 
.................... #define B00111101 61 
.................... #define B111110 62 
.................... #define B0111110 62 
.................... #define B00111110 62 
.................... #define B111111 63 
.................... #define B0111111 63 
.................... #define B00111111 63 
.................... #define B1000000 64 
.................... #define B01000000 64 
.................... #define B1000001 65 
.................... #define B01000001 65 
.................... #define B1000010 66 
.................... #define B01000010 66 
.................... #define B1000011 67 
.................... #define B01000011 67 
.................... #define B1000100 68 
.................... #define B01000100 68 
.................... #define B1000101 69 
.................... #define B01000101 69 
.................... #define B1000110 70 
.................... #define B01000110 70 
.................... #define B1000111 71 
.................... #define B01000111 71 
.................... #define B1001000 72 
.................... #define B01001000 72 
.................... #define B1001001 73 
.................... #define B01001001 73 
.................... #define B1001010 74 
.................... #define B01001010 74 
.................... #define B1001011 75 
.................... #define B01001011 75 
.................... #define B1001100 76 
.................... #define B01001100 76 
.................... #define B1001101 77 
.................... #define B01001101 77 
.................... #define B1001110 78 
.................... #define B01001110 78 
.................... #define B1001111 79 
.................... #define B01001111 79 
.................... #define B1010000 80 
.................... #define B01010000 80 
.................... #define B1010001 81 
.................... #define B01010001 81 
.................... #define B1010010 82 
.................... #define B01010010 82 
.................... #define B1010011 83 
.................... #define B01010011 83 
.................... #define B1010100 84 
.................... #define B01010100 84 
.................... #define B1010101 85 
.................... #define B01010101 85 
.................... #define B1010110 86 
.................... #define B01010110 86 
.................... #define B1010111 87 
.................... #define B01010111 87 
.................... #define B1011000 88 
.................... #define B01011000 88 
.................... #define B1011001 89 
.................... #define B01011001 89 
.................... #define B1011010 90 
.................... #define B01011010 90 
.................... #define B1011011 91 
.................... #define B01011011 91 
.................... #define B1011100 92 
.................... #define B01011100 92 
.................... #define B1011101 93 
.................... #define B01011101 93 
.................... #define B1011110 94 
.................... #define B01011110 94 
.................... #define B1011111 95 
.................... #define B01011111 95 
.................... #define B1100000 96 
.................... #define B01100000 96 
.................... #define B1100001 97 
.................... #define B01100001 97 
.................... #define B1100010 98 
.................... #define B01100010 98 
.................... #define B1100011 99 
.................... #define B01100011 99 
.................... #define B1100100 100 
.................... #define B01100100 100 
.................... #define B1100101 101 
.................... #define B01100101 101 
.................... #define B1100110 102 
.................... #define B01100110 102 
.................... #define B1100111 103 
.................... #define B01100111 103 
.................... #define B1101000 104 
.................... #define B01101000 104 
.................... #define B1101001 105 
.................... #define B01101001 105 
.................... #define B1101010 106 
.................... #define B01101010 106 
.................... #define B1101011 107 
.................... #define B01101011 107 
.................... #define B1101100 108 
.................... #define B01101100 108 
.................... #define B1101101 109 
.................... #define B01101101 109 
.................... #define B1101110 110 
.................... #define B01101110 110 
.................... #define B1101111 111 
.................... #define B01101111 111 
.................... #define B1110000 112 
.................... #define B01110000 112 
.................... #define B1110001 113 
.................... #define B01110001 113 
.................... #define B1110010 114 
.................... #define B01110010 114 
.................... #define B1110011 115 
.................... #define B01110011 115 
.................... #define B1110100 116 
.................... #define B01110100 116 
.................... #define B1110101 117 
.................... #define B01110101 117 
.................... #define B1110110 118 
.................... #define B01110110 118 
.................... #define B1110111 119 
.................... #define B01110111 119 
.................... #define B1111000 120 
.................... #define B01111000 120 
.................... #define B1111001 121 
.................... #define B01111001 121 
.................... #define B1111010 122 
.................... #define B01111010 122 
.................... #define B1111011 123 
.................... #define B01111011 123 
.................... #define B1111100 124 
.................... #define B01111100 124 
.................... #define B1111101 125 
.................... #define B01111101 125 
.................... #define B1111110 126 
.................... #define B01111110 126 
.................... #define B1111111 127 
.................... #define B01111111 127 
.................... #define B10000000 128 
.................... #define B10000001 129 
.................... #define B10000010 130 
.................... #define B10000011 131 
.................... #define B10000100 132 
.................... #define B10000101 133 
.................... #define B10000110 134 
.................... #define B10000111 135 
.................... #define B10001000 136 
.................... #define B10001001 137 
.................... #define B10001010 138 
.................... #define B10001011 139 
.................... #define B10001100 140 
.................... #define B10001101 141 
.................... #define B10001110 142 
.................... #define B10001111 143 
.................... #define B10010000 144 
.................... #define B10010001 145 
.................... #define B10010010 146 
.................... #define B10010011 147 
.................... #define B10010100 148 
.................... #define B10010101 149 
.................... #define B10010110 150 
.................... #define B10010111 151 
.................... #define B10011000 152 
.................... #define B10011001 153 
.................... #define B10011010 154 
.................... #define B10011011 155 
.................... #define B10011100 156 
.................... #define B10011101 157 
.................... #define B10011110 158 
.................... #define B10011111 159 
.................... #define B10100000 160 
.................... #define B10100001 161 
.................... #define B10100010 162 
.................... #define B10100011 163 
.................... #define B10100100 164 
.................... #define B10100101 165 
.................... #define B10100110 166 
.................... #define B10100111 167 
.................... #define B10101000 168 
.................... #define B10101001 169 
.................... #define B10101010 170 
.................... #define B10101011 171 
.................... #define B10101100 172 
.................... #define B10101101 173 
.................... #define B10101110 174 
.................... #define B10101111 175 
.................... #define B10110000 176 
.................... #define B10110001 177 
.................... #define B10110010 178 
.................... #define B10110011 179 
.................... #define B10110100 180 
.................... #define B10110101 181 
.................... #define B10110110 182 
.................... #define B10110111 183 
.................... #define B10111000 184 
.................... #define B10111001 185 
.................... #define B10111010 186 
.................... #define B10111011 187 
.................... #define B10111100 188 
.................... #define B10111101 189 
.................... #define B10111110 190 
.................... #define B10111111 191 
.................... #define B11000000 192 
.................... #define B11000001 193 
.................... #define B11000010 194 
.................... #define B11000011 195 
.................... #define B11000100 196 
.................... #define B11000101 197 
.................... #define B11000110 198 
.................... #define B11000111 199 
.................... #define B11001000 200 
.................... #define B11001001 201 
.................... #define B11001010 202 
.................... #define B11001011 203 
.................... #define B11001100 204 
.................... #define B11001101 205 
.................... #define B11001110 206 
.................... #define B11001111 207 
.................... #define B11010000 208 
.................... #define B11010001 209 
.................... #define B11010010 210 
.................... #define B11010011 211 
.................... #define B11010100 212 
.................... #define B11010101 213 
.................... #define B11010110 214 
.................... #define B11010111 215 
.................... #define B11011000 216 
.................... #define B11011001 217 
.................... #define B11011010 218 
.................... #define B11011011 219 
.................... #define B11011100 220 
.................... #define B11011101 221 
.................... #define B11011110 222 
.................... #define B11011111 223 
.................... #define B11100000 224 
.................... #define B11100001 225 
.................... #define B11100010 226 
.................... #define B11100011 227 
.................... #define B11100100 228 
.................... #define B11100101 229 
.................... #define B11100110 230 
.................... #define B11100111 231 
.................... #define B11101000 232 
.................... #define B11101001 233 
.................... #define B11101010 234 
.................... #define B11101011 235 
.................... #define B11101100 236 
.................... #define B11101101 237 
.................... #define B11101110 238 
.................... #define B11101111 239 
.................... #define B11110000 240 
.................... #define B11110001 241 
.................... #define B11110010 242 
.................... #define B11110011 243 
.................... #define B11110100 244 
.................... #define B11110101 245 
.................... #define B11110110 246 
.................... #define B11110111 247 
.................... #define B11111000 248 
.................... #define B11111001 249 
.................... #define B11111010 250 
.................... #define B11111011 251 
.................... #define B11111100 252 
.................... #define B11111101 253 
.................... #define B11111110 254 
.................... #define B11111111 255 
....................  
.................... #endif /* _INC_OCTOPLUS_STACK_CONFIG_H */ 
....................  
.................... #INCLUDE <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
0114C:  BCF    FF2.2
0114E:  GOTO   1068
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //############################ 
.................... //Declaracion de caracteristicas del circuito de displays 7 segmentos 
.................... #define NUM_DISPLAYS 4 
.................... #define CATODO_COMUN 0x01 
.................... #define ANODO_COMUN 0x00 
.................... #define NPN 0x01 
.................... #define PNP 0x00 
.................... #define output_Displays(x) output_d(x) 
.................... #define TIME_MUX 1000 // tiempo de multiplexacion en microsegundos 
....................  
....................      //Tipos de displays   //tipo de transistores 
.................... int1 D7Seg= CATODO_COMUN , Q = PNP; 
....................  
.................... //############################ 
.................... /********************************************************/ 
.................... /*------- Espacio para declaracion de constantes  ------*/ 
.................... /********************************************************/ 
.................... const unsigned int16 transistorPins[NUM_DISPLAYS]={PIN_A3,PIN_A2,PIN_A1,PIN_A0}; 
.................... const unsigned char Tabla7seg[10]= 
.................... { // HGFEDCBA <-- Segmento 
....................    0b00111111, // 0 
....................    0b00000110, // 1 
....................    0b01011011, // 2 
....................    0b01001111, // 3 
....................    0b01100110, // 4 
....................    0b01101101, // 5 
....................    0b01111101, // 6 
....................    0b00000111, // 7 
....................    0b01111111, // 8 
....................    0b01100111  // 9 
.................... }; 
....................  
.................... float val=-2.100; 
.................... signed int16 num=6253; 
.................... /********************************************************/ 
.................... /*--- Espacio para declaracion de variables globales  --*/ 
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /********************************************************/ 
.................... /*-------------- Espacio para funciones  ---------------*/ 
.................... /********************************************************/ 
.................... void displayMux(float numero,unsigned int16 time,char precision=0); 
....................  
.................... /******************************************************************************/ 
.................... /******************************************************************************/ 
.................... /*--------------------- Espacio de codigo principal --------------------------*/ 
.................... /******************************************************************************/  
.................... #zero_ram 
....................  
.................... void main() 
.................... { 
*
023A8:  CLRF   FF8
023AA:  BCF    FD0.7
023AC:  BSF    07.7
023AE:  MOVLB  E
023B0:  MOVLW  55
023B2:  MOVWF  FA7
023B4:  MOVLW  AA
023B6:  MOVWF  FA7
023B8:  BCF    xBF.0
023BA:  MOVLW  14
023BC:  MOVWF  xF7
023BE:  MOVLW  06
023C0:  MOVWF  xD3
023C2:  MOVLW  55
023C4:  MOVWF  FA7
023C6:  MOVLW  AA
023C8:  MOVWF  FA7
023CA:  BSF    xBF.0
023CC:  MOVLW  AE
023CE:  MOVWF  00
023D0:  MOVLW  0F
023D2:  MOVWF  01
023D4:  MOVLW  02
023D6:  MOVWF  FE9
023D8:  MOVLW  00
023DA:  MOVWF  FEA
023DC:  CLRF   FEE
023DE:  DECFSZ 00,F
023E0:  BRA    23DC
023E2:  DECFSZ 01,F
023E4:  BRA    23DC
023E6:  CLRF   FEA
023E8:  CLRF   FE9
023EA:  BSF    29.0
023EC:  BCF    29.1
023EE:  MOVLW  66
023F0:  MOVWF  2D
023F2:  MOVWF  2C
023F4:  MOVLW  86
023F6:  MOVWF  2B
023F8:  MOVLW  80
023FA:  MOVWF  2A
023FC:  MOVLW  18
023FE:  MOVWF  2F
02400:  MOVLW  6D
02402:  MOVWF  2E
02404:  CLRF   35
02406:  CLRF   3B
02408:  CLRF   3A
0240A:  CLRF   3D
0240C:  CLRF   3C
0240E:  CLRF   41
02410:  CLRF   40
02412:  BCF    29.2
02414:  BCF    29.3
02416:  MOVLB  1
02418:  CLRF   x88
0241A:  MOVLW  FF
0241C:  MOVLB  F
0241E:  MOVWF  x48
02420:  BCF    FC2.6
02422:  BCF    FC2.7
02424:  MOVF   x49,W
02426:  ANDLW  E0
02428:  IORLW  1F
0242A:  MOVWF  x49
0242C:  CLRF   x25
0242E:  CLRF   FD1
02430:  CLRF   FD2
02432:  CLRF   1F
02434:  CLRF   20
02436:  CLRF   21
02438:  CLRF   22
0243A:  CLRF   23
0243C:  CLRF   24
....................    mcu_init (); // Inicializa microcontrolador 
0243E:  BSF    F9B.6
02440:  MOVLW  81
02442:  MOVWF  FD5
02444:  MOVLW  F4
02446:  MOVWF  FD7
02448:  MOVLW  48
0244A:  MOVWF  FD6
0244C:  BSF    FF2.5
....................    set_tris_d (0) ; 
0244E:  MOVLW  00
02450:  MOVWF  F95
....................    set_tris_a (0) ; 
02452:  MOVWF  F92
....................    for (;;) 
....................    { 
....................       displayMux (-0.014,5,2) ; 
02454:  MOVLW  42
02456:  MOVWF  45
02458:  MOVLW  60
0245A:  MOVWF  44
0245C:  MOVLW  E5
0245E:  MOVWF  43
02460:  MOVLW  78
02462:  MOVWF  42
02464:  CLRF   47
02466:  MOVLW  05
02468:  MOVWF  46
0246A:  MOVLW  02
0246C:  MOVWF  48
0246E:  MOVLB  0
02470:  GOTO   18EA
....................      val= val + 0.010; 
02474:  BCF    FD8.1
02476:  MOVFF  2D,50
0247A:  MOVFF  2C,4F
0247E:  MOVFF  2B,4E
02482:  MOVFF  2A,4D
02486:  MOVLW  0A
02488:  MOVWF  54
0248A:  MOVLW  D7
0248C:  MOVWF  53
0248E:  MOVLW  23
02490:  MOVWF  52
02492:  MOVLW  78
02494:  MOVWF  51
02496:  CALL   161A
0249A:  MOVFF  03,2D
0249E:  MOVFF  02,2C
024A2:  MOVFF  01,2B
024A6:  MOVFF  00,2A
....................    }//end void loop 
024AA:  MOVLB  F
024AC:  BRA    2454
.................... }//end main 
....................  
.................... void displayMux(float numero,unsigned int16 time,char precision=0) 
.................... { 
024AE:  SLEEP 
....................   //Crea variables estaticas dentro de la función para evitar conflictos con el código del menu principal 
....................    static unsigned char digito[NUM_DISPLAYS]; 
....................    static unsigned int size, max = 0; 
....................    static signed int32 temp; 
....................    static int16 i = 0, j = 0, decimal, dec = 0; 
....................    static int1 signo = 0, limit = 0; 
....................    static const unsigned int32 powersOf10[]  = 
....................    { 
....................       1, // 10 ^ 0 
....................       10, 
....................       100, 
....................       1000, 
....................       10000, 
....................       100000, 
....................       1000000, 
....................       10000000, 
....................       100000000, 
....................       1000000000 
....................    }; // 10 ^ 9 
....................    memset(digito, 0, NUM_DISPLAYS);//Borra los digitos anteriores 
*
018EA:  CLRF   FEA
018EC:  MOVLW  30
018EE:  MOVWF  FE9
018F0:  CLRF   49
018F2:  CLRF   4B
018F4:  MOVLW  04
018F6:  MOVWF  4A
018F8:  BRA    1152
....................   temp = numero; //Separa la parte entera 
018FA:  MOVFF  45,4C
018FE:  MOVFF  44,4B
01902:  MOVFF  43,4A
01906:  MOVFF  42,49
0190A:  RCALL  116E
0190C:  MOVFF  03,39
01910:  MOVFF  02,38
01914:  MOVFF  01,37
01918:  MOVFF  00,36
....................    if (numero < 0) 
0191C:  MOVFF  45,50
01920:  MOVFF  44,4F
01924:  MOVFF  43,4E
01928:  MOVFF  42,4D
0192C:  CLRF   54
0192E:  CLRF   53
01930:  CLRF   52
01932:  CLRF   51
01934:  RCALL  11AC
01936:  BNC   19A0
....................    { 
....................       temp = abs (numero);  
01938:  CLRF   50
0193A:  CLRF   4F
0193C:  CLRF   4E
0193E:  CLRF   4D
01940:  MOVFF  45,54
01944:  MOVFF  44,53
01948:  MOVFF  43,52
0194C:  MOVFF  42,51
01950:  RCALL  11AC
01952:  BNC   1968
01954:  MOVFF  45,4C
01958:  MOVFF  44,4B
0195C:  MOVFF  43,4A
01960:  MOVFF  42,49
01964:  RCALL  116E
01966:  BRA    198C
01968:  MOVFF  42,00
0196C:  MOVF   43,W
0196E:  XORLW  80
01970:  MOVWF  01
01972:  MOVFF  44,02
01976:  MOVFF  45,03
0197A:  MOVFF  45,4C
0197E:  MOVFF  44,4B
01982:  MOVWF  4A
01984:  MOVFF  42,49
01988:  CALL   116E
0198C:  MOVFF  03,39
01990:  MOVFF  02,38
01994:  MOVFF  01,37
01998:  MOVFF  00,36
....................       signo = 1; //Verifica si el numero es negativo 
0199C:  BSF    29.2
....................       }else{ 
0199E:  BRA    19A2
....................       signo = 0; 
019A0:  BCF    29.2
....................    } 
....................    max = NUM_DISPLAYS - precision - signo; //Calcula el numero de displays maximos para terminar los rangos permitidos 
019A2:  MOVLW  04
019A4:  BSF    FD8.0
019A6:  SUBFWB 48,W
019A8:  MOVWF  4A
019AA:  MOVLW  00
019AC:  BTFSC  29.2
019AE:  MOVLW  01
019B0:  SUBWF  4A,W
019B2:  MOVWF  35
....................    limit = (signo) ? numero > (powersOf10[max] * - 1): numero < powersOf10[max]; // determina si el limite del numero segun los digitos ingresados 
019B4:  BTFSS  29.2
019B6:  BRA    1A3C
019B8:  MOVF   35,W
019BA:  MULLW  04
019BC:  MOVF   FF3,W
019BE:  CLRF   03
019C0:  CALL   10F8
019C4:  MOVWF  00
019C6:  TBLRD*+
019C8:  MOVFF  FF5,01
019CC:  TBLRD*+
019CE:  MOVFF  FF5,02
019D2:  TBLRD*+
019D4:  MOVFF  FF5,03
019D8:  MOVFF  03,4C
019DC:  MOVFF  02,4B
019E0:  MOVFF  01,4A
019E4:  MOVWF  49
019E6:  MOVFF  03,50
019EA:  MOVFF  02,4F
019EE:  MOVFF  01,4E
019F2:  MOVWF  4D
019F4:  SETF   54
019F6:  SETF   53
019F8:  SETF   52
019FA:  SETF   51
019FC:  BRA    1222
019FE:  MOVFF  03,4C
01A02:  MOVFF  02,4B
01A06:  MOVFF  01,4A
01A0A:  MOVFF  00,49
01A0E:  BRA    1278
01A10:  MOVFF  03,50
01A14:  MOVFF  02,4F
01A18:  MOVFF  01,4E
01A1C:  MOVFF  00,4D
01A20:  MOVFF  45,54
01A24:  MOVFF  44,53
01A28:  MOVFF  43,52
01A2C:  MOVFF  42,51
01A30:  CALL   11AC
01A34:  MOVLW  00
01A36:  BTFSC  FD8.0
01A38:  MOVLW  01
01A3A:  BRA    1A96
01A3C:  MOVF   35,W
01A3E:  MULLW  04
01A40:  MOVF   FF3,W
01A42:  CLRF   03
01A44:  CALL   10F8
01A48:  MOVWF  00
01A4A:  TBLRD*+
01A4C:  MOVFF  FF5,01
01A50:  TBLRD*+
01A52:  MOVFF  FF5,02
01A56:  TBLRD*+
01A58:  MOVFF  FF5,03
01A5C:  MOVFF  03,4C
01A60:  MOVFF  02,4B
01A64:  MOVFF  01,4A
01A68:  MOVWF  49
01A6A:  RCALL  12D0
01A6C:  MOVFF  45,50
01A70:  MOVFF  44,4F
01A74:  MOVFF  43,4E
01A78:  MOVFF  42,4D
01A7C:  MOVFF  03,54
01A80:  MOVFF  02,53
01A84:  MOVFF  01,52
01A88:  MOVFF  00,51
01A8C:  CALL   11AC
01A90:  MOVLW  00
01A92:  BTFSC  FD8.0
01A94:  MOVLW  01
01A96:  BCF    29.3
01A98:  BTFSC  FE8.0
01A9A:  BSF    29.3
....................    if (precision > 0)       //Separa la parte decimal siempre y se escogen la cantidad de decimales 
01A9C:  MOVF   48,F
01A9E:  BTFSC  FD8.2
01AA0:  BRA    1C74
....................    { 
....................       decimal = abs (numero * powersOf10[precision]) ; 
01AA2:  MOVF   48,W
01AA4:  MULLW  04
01AA6:  MOVF   FF3,W
01AA8:  CLRF   03
01AAA:  CALL   10F8
01AAE:  MOVWF  00
01AB0:  TBLRD*+
01AB2:  MOVFF  FF5,01
01AB6:  TBLRD*+
01AB8:  MOVFF  FF5,02
01ABC:  TBLRD*+
01ABE:  MOVFF  FF5,03
01AC2:  MOVFF  03,4C
01AC6:  MOVFF  02,4B
01ACA:  MOVFF  01,4A
01ACE:  MOVWF  49
01AD0:  CALL   12D0
01AD4:  MOVFF  45,4C
01AD8:  MOVFF  44,4B
01ADC:  MOVFF  43,4A
01AE0:  MOVFF  42,49
01AE4:  MOVFF  03,50
01AE8:  MOVFF  02,4F
01AEC:  MOVFF  01,4E
01AF0:  MOVFF  00,4D
01AF4:  RCALL  1304
01AF6:  MOVFF  00,49
01AFA:  MOVFF  01,4A
01AFE:  MOVFF  02,4B
01B02:  MOVFF  03,4C
01B06:  CLRF   50
01B08:  CLRF   4F
01B0A:  CLRF   4E
01B0C:  CLRF   4D
01B0E:  MOVFF  03,54
01B12:  MOVFF  02,53
01B16:  MOVFF  01,52
01B1A:  MOVFF  00,51
01B1E:  CALL   11AC
01B22:  BNC   1B94
01B24:  MOVF   48,W
01B26:  MULLW  04
01B28:  MOVF   FF3,W
01B2A:  CLRF   03
01B2C:  CALL   10F8
01B30:  MOVWF  00
01B32:  TBLRD*+
01B34:  MOVFF  FF5,01
01B38:  TBLRD*+
01B3A:  MOVFF  FF5,02
01B3E:  TBLRD*+
01B40:  MOVFF  FF5,03
01B44:  MOVFF  03,4C
01B48:  MOVFF  02,4B
01B4C:  MOVFF  01,4A
01B50:  MOVWF  49
01B52:  CALL   12D0
01B56:  MOVFF  45,4C
01B5A:  MOVFF  44,4B
01B5E:  MOVFF  43,4A
01B62:  MOVFF  42,49
01B66:  MOVFF  03,50
01B6A:  MOVFF  02,4F
01B6E:  MOVFF  01,4E
01B72:  MOVFF  00,4D
01B76:  CALL   1304
01B7A:  MOVFF  03,4C
01B7E:  MOVFF  02,4B
01B82:  MOVFF  01,4A
01B86:  MOVFF  00,49
01B8A:  RCALL  13F6
01B8C:  MOVFF  02,03
01B90:  MOVF   01,W
01B92:  BRA    1C08
01B94:  MOVF   48,W
01B96:  MULLW  04
01B98:  MOVF   FF3,W
01B9A:  CLRF   03
01B9C:  CALL   10F8
01BA0:  MOVWF  00
01BA2:  TBLRD*+
01BA4:  MOVFF  FF5,01
01BA8:  TBLRD*+
01BAA:  MOVFF  FF5,02
01BAE:  TBLRD*+
01BB0:  MOVFF  FF5,03
01BB4:  MOVFF  03,4C
01BB8:  MOVFF  02,4B
01BBC:  MOVFF  01,4A
01BC0:  MOVWF  49
01BC2:  CALL   12D0
01BC6:  MOVFF  45,4C
01BCA:  MOVFF  44,4B
01BCE:  MOVFF  43,4A
01BD2:  MOVFF  42,49
01BD6:  MOVFF  03,50
01BDA:  MOVFF  02,4F
01BDE:  MOVFF  01,4E
01BE2:  MOVFF  00,4D
01BE6:  CALL   1304
01BEA:  MOVF   01,W
01BEC:  XORLW  80
01BEE:  MOVWF  01
01BF0:  MOVFF  03,4C
01BF4:  MOVFF  02,4B
01BF8:  MOVWF  4A
01BFA:  MOVFF  00,49
01BFE:  CALL   13F6
01C02:  MOVFF  02,03
01C06:  MOVF   01,W
01C08:  MOVWF  3E
01C0A:  MOVFF  03,3F
....................       decimal %= powersOf10[precision]; 
01C0E:  MOVF   48,W
01C10:  MULLW  04
01C12:  MOVF   FF3,W
01C14:  CLRF   03
01C16:  CALL   10F8
01C1A:  MOVWF  00
01C1C:  TBLRD*+
01C1E:  MOVFF  FF5,01
01C22:  TBLRD*+
01C24:  MOVFF  FF5,02
01C28:  TBLRD*+
01C2A:  MOVFF  FF5,03
01C2E:  MOVFF  03,4C
01C32:  MOVFF  02,4B
01C36:  MOVFF  01,4A
01C3A:  MOVWF  49
01C3C:  BSF    FD8.1
01C3E:  CLRF   FEA
01C40:  MOVLW  4D
01C42:  MOVWF  FE9
01C44:  CLRF   54
01C46:  CLRF   53
01C48:  MOVFF  3F,52
01C4C:  MOVFF  3E,51
01C50:  MOVFF  03,58
01C54:  MOVFF  02,57
01C58:  MOVFF  01,56
01C5C:  MOVFF  00,55
01C60:  GOTO   142E
01C64:  MOVFF  4E,3F
01C68:  MOVFF  4D,3E
....................       dec=decimal; 
01C6C:  MOVFF  3F,41
01C70:  MOVFF  3E,40
....................    } 
....................  
....................    if (limit)// condicion para calcular los digitos si el numero ingresado es menor que el posible a mostrar 
01C74:  BTFSS  29.3
01C76:  BRA    20D0
....................    { 
....................       size = 0; 
01C78:  CLRF   34
....................        //Obtiene los digitos y cuenta cuantos digitos son 
....................       do{ 
....................          if (precision > 0 && size < precision)  
01C7A:  MOVF   48,F
01C7C:  BZ    1D06
01C7E:  MOVF   48,W
01C80:  SUBWF  34,W
01C82:  BC    1D06
....................          { 
....................            digito[size] = abs(decimal % 10); 
01C84:  CLRF   03
01C86:  MOVF   34,W
01C88:  ADDLW  30
01C8A:  MOVWF  FE9
01C8C:  MOVLW  00
01C8E:  ADDWFC 03,W
01C90:  MOVWF  FEA
01C92:  MOVFF  3F,4C
01C96:  MOVFF  3E,4B
01C9A:  CLRF   4E
01C9C:  MOVLW  0A
01C9E:  MOVWF  4D
01CA0:  RCALL  14BE
01CA2:  MOVFF  00,4B
01CA6:  MOVFF  03,4C
01CAA:  MOVF   4B,F
01CAC:  BNZ   1CB2
01CAE:  MOVF   4C,F
01CB0:  BZ    1CC8
01CB2:  MOVFF  3F,4C
01CB6:  MOVFF  3E,4B
01CBA:  CLRF   4E
01CBC:  MOVLW  0A
01CBE:  MOVWF  4D
01CC0:  CALL   14BE
01CC4:  MOVF   00,W
01CC6:  BRA    1CE8
01CC8:  MOVFF  3F,4C
01CCC:  MOVFF  3E,4B
01CD0:  CLRF   4E
01CD2:  MOVLW  0A
01CD4:  MOVWF  4D
01CD6:  CALL   14BE
01CDA:  MOVF   00,W
01CDC:  XORLW  FF
01CDE:  ADDLW  01
01CE0:  MOVWF  00
01CE2:  MOVLW  00
01CE4:  SUBFWB 03,F
01CE6:  MOVF   00,W
01CE8:  MOVWF  FEF
....................             decimal /= 10; 
01CEA:  MOVFF  3F,4C
01CEE:  MOVFF  3E,4B
01CF2:  CLRF   4E
01CF4:  MOVLW  0A
01CF6:  MOVWF  4D
01CF8:  CALL   14BE
01CFC:  MOVFF  02,3F
01D00:  MOVFF  01,3E
....................             }else{ 
01D04:  BRA    1D8C
....................             digito[size] = temp % 10; 
01D06:  CLRF   03
01D08:  MOVF   34,W
01D0A:  ADDLW  30
01D0C:  MOVWF  01
01D0E:  MOVLW  00
01D10:  ADDWFC 03,F
01D12:  MOVFF  01,49
01D16:  MOVFF  03,4A
01D1A:  MOVFF  FEA,4C
01D1E:  MOVFF  FE9,4B
01D22:  BSF    FD8.1
01D24:  CLRF   FEA
01D26:  MOVLW  4D
01D28:  MOVWF  FE9
01D2A:  MOVFF  39,54
01D2E:  MOVFF  38,53
01D32:  MOVFF  37,52
01D36:  MOVFF  36,51
01D3A:  CLRF   58
01D3C:  CLRF   57
01D3E:  CLRF   56
01D40:  MOVLW  0A
01D42:  MOVWF  55
01D44:  CALL   1500
01D48:  MOVFF  4C,FEA
01D4C:  MOVFF  4B,FE9
01D50:  MOVFF  4A,FEA
01D54:  MOVFF  49,FE9
01D58:  MOVFF  4D,FEF
....................             temp /= 10; 
01D5C:  BCF    FD8.1
01D5E:  MOVFF  39,54
01D62:  MOVFF  38,53
01D66:  MOVFF  37,52
01D6A:  MOVFF  36,51
01D6E:  CLRF   58
01D70:  CLRF   57
01D72:  CLRF   56
01D74:  MOVLW  0A
01D76:  MOVWF  55
01D78:  CALL   1500
01D7C:  MOVFF  03,39
01D80:  MOVFF  02,38
01D84:  MOVFF  01,37
01D88:  MOVFF  00,36
....................          } 
....................          size++; 
01D8C:  INCF   34,F
....................       }while (temp > 0 || decimal > 0); 
01D8E:  BTFSC  39.7
01D90:  BRA    1DAC
01D92:  MOVF   39,F
01D94:  BTFSS  FD8.2
01D96:  BRA    1C7A
01D98:  MOVF   38,F
01D9A:  BTFSS  FD8.2
01D9C:  BRA    1C7A
01D9E:  MOVF   37,F
01DA0:  BTFSS  FD8.2
01DA2:  BRA    1C7A
01DA4:  MOVF   36,W
01DA6:  SUBLW  00
01DA8:  BTFSS  FD8.0
01DAA:  BRA    1C7A
01DAC:  MOVF   3E,F
01DAE:  BTFSS  FD8.2
01DB0:  BRA    1C7A
01DB2:  MOVF   3F,F
01DB4:  BTFSS  FD8.2
01DB6:  BRA    1C7A
....................    temp=abs(numero); 
01DB8:  CLRF   50
01DBA:  CLRF   4F
01DBC:  CLRF   4E
01DBE:  CLRF   4D
01DC0:  MOVFF  45,54
01DC4:  MOVFF  44,53
01DC8:  MOVFF  43,52
01DCC:  MOVFF  42,51
01DD0:  CALL   11AC
01DD4:  BNC   1DEC
01DD6:  MOVFF  45,4C
01DDA:  MOVFF  44,4B
01DDE:  MOVFF  43,4A
01DE2:  MOVFF  42,49
01DE6:  CALL   116E
01DEA:  BRA    1E10
01DEC:  MOVFF  42,00
01DF0:  MOVF   43,W
01DF2:  XORLW  80
01DF4:  MOVWF  01
01DF6:  MOVFF  44,02
01DFA:  MOVFF  45,03
01DFE:  MOVFF  45,4C
01E02:  MOVFF  44,4B
01E06:  MOVWF  4A
01E08:  MOVFF  42,49
01E0C:  CALL   116E
01E10:  MOVFF  03,39
01E14:  MOVFF  02,38
01E18:  MOVFF  01,37
01E1C:  MOVFF  00,36
....................    size+=(signo && temp==0 && precision > 1) ? (precision - round(precision*0.5)) : (temp>=1) ? 0 : round(precision*0.5); 
01E20:  BTFSS  29.2
01E22:  BRA    1F7E
01E24:  MOVF   36,F
01E26:  BTFSS  FD8.2
01E28:  BRA    1F7E
01E2A:  MOVF   37,F
01E2C:  BTFSS  FD8.2
01E2E:  BRA    1F7E
01E30:  MOVF   38,F
01E32:  BTFSS  FD8.2
01E34:  BRA    1F7E
01E36:  MOVF   39,F
01E38:  BTFSS  FD8.2
01E3A:  BRA    1F7E
01E3C:  MOVF   48,W
01E3E:  SUBLW  01
01E40:  BTFSC  FD8.0
01E42:  BRA    1F7E
01E44:  CLRF   4A
01E46:  MOVFF  48,49
01E4A:  CALL   15E4
01E4E:  MOVFF  03,4C
01E52:  MOVFF  02,4B
01E56:  MOVFF  01,4A
01E5A:  MOVFF  00,49
01E5E:  CLRF   50
01E60:  CLRF   4F
01E62:  CLRF   4E
01E64:  MOVLW  7E
01E66:  MOVWF  4D
01E68:  CALL   1304
01E6C:  MOVFF  00,49
01E70:  MOVFF  01,4A
01E74:  MOVFF  02,4B
01E78:  MOVFF  03,4C
01E7C:  CLRF   50
01E7E:  CLRF   4F
01E80:  CLRF   4E
01E82:  CLRF   4D
01E84:  MOVFF  03,54
01E88:  MOVFF  02,53
01E8C:  MOVFF  01,52
01E90:  MOVFF  00,51
01E94:  CALL   11AC
01E98:  BC    1E9C
01E9A:  BNZ   1F0C
01E9C:  CLRF   4A
01E9E:  MOVFF  48,49
01EA2:  CALL   15E4
01EA6:  MOVFF  03,4C
01EAA:  MOVFF  02,4B
01EAE:  MOVFF  01,4A
01EB2:  MOVFF  00,49
01EB6:  CLRF   50
01EB8:  CLRF   4F
01EBA:  CLRF   4E
01EBC:  MOVLW  7E
01EBE:  MOVWF  4D
01EC0:  CALL   1304
01EC4:  MOVFF  00,49
01EC8:  MOVFF  01,4A
01ECC:  MOVFF  02,4B
01ED0:  MOVFF  03,4C
01ED4:  BCF    FD8.1
01ED6:  MOVFF  03,50
01EDA:  MOVFF  02,4F
01EDE:  MOVFF  01,4E
01EE2:  MOVFF  00,4D
01EE6:  CLRF   54
01EE8:  CLRF   53
01EEA:  CLRF   52
01EEC:  MOVLW  7E
01EEE:  MOVWF  51
01EF0:  CALL   161A
01EF4:  MOVFF  03,4C
01EF8:  MOVFF  02,4B
01EFC:  MOVFF  01,4A
01F00:  MOVFF  00,49
01F04:  CALL   13F6
01F08:  MOVF   01,W
01F0A:  BRA    1F7A
01F0C:  CLRF   4A
01F0E:  MOVFF  48,49
01F12:  CALL   15E4
01F16:  MOVFF  03,4C
01F1A:  MOVFF  02,4B
01F1E:  MOVFF  01,4A
01F22:  MOVFF  00,49
01F26:  CLRF   50
01F28:  CLRF   4F
01F2A:  CLRF   4E
01F2C:  MOVLW  7E
01F2E:  MOVWF  4D
01F30:  CALL   1304
01F34:  MOVFF  00,49
01F38:  MOVFF  01,4A
01F3C:  MOVFF  02,4B
01F40:  MOVFF  03,4C
01F44:  BSF    FD8.1
01F46:  MOVFF  03,50
01F4A:  MOVFF  02,4F
01F4E:  MOVFF  01,4E
01F52:  MOVFF  00,4D
01F56:  CLRF   54
01F58:  CLRF   53
01F5A:  CLRF   52
01F5C:  MOVLW  7E
01F5E:  MOVWF  51
01F60:  CALL   161A
01F64:  MOVFF  03,4C
01F68:  MOVFF  02,4B
01F6C:  MOVFF  01,4A
01F70:  MOVFF  00,49
01F74:  CALL   13F6
01F78:  MOVF   01,W
01F7A:  SUBWF  48,W
01F7C:  BRA    20CE
01F7E:  BTFSC  39.7
01F80:  BRA    1F98
01F82:  MOVF   39,F
01F84:  BNZ   1F94
01F86:  MOVF   38,F
01F88:  BNZ   1F94
01F8A:  MOVF   37,F
01F8C:  BNZ   1F94
01F8E:  MOVF   36,W
01F90:  SUBLW  00
01F92:  BC    1F98
01F94:  MOVLW  00
01F96:  BRA    20CE
01F98:  CLRF   4A
01F9A:  MOVFF  48,49
01F9E:  CALL   15E4
01FA2:  MOVFF  03,4C
01FA6:  MOVFF  02,4B
01FAA:  MOVFF  01,4A
01FAE:  MOVFF  00,49
01FB2:  CLRF   50
01FB4:  CLRF   4F
01FB6:  CLRF   4E
01FB8:  MOVLW  7E
01FBA:  MOVWF  4D
01FBC:  CALL   1304
01FC0:  MOVFF  00,49
01FC4:  MOVFF  01,4A
01FC8:  MOVFF  02,4B
01FCC:  MOVFF  03,4C
01FD0:  CLRF   50
01FD2:  CLRF   4F
01FD4:  CLRF   4E
01FD6:  CLRF   4D
01FD8:  MOVFF  03,54
01FDC:  MOVFF  02,53
01FE0:  MOVFF  01,52
01FE4:  MOVFF  00,51
01FE8:  CALL   11AC
01FEC:  BC    1FF0
01FEE:  BNZ   2060
01FF0:  CLRF   4A
01FF2:  MOVFF  48,49
01FF6:  CALL   15E4
01FFA:  MOVFF  03,4C
01FFE:  MOVFF  02,4B
02002:  MOVFF  01,4A
02006:  MOVFF  00,49
0200A:  CLRF   50
0200C:  CLRF   4F
0200E:  CLRF   4E
02010:  MOVLW  7E
02012:  MOVWF  4D
02014:  CALL   1304
02018:  MOVFF  00,49
0201C:  MOVFF  01,4A
02020:  MOVFF  02,4B
02024:  MOVFF  03,4C
02028:  BCF    FD8.1
0202A:  MOVFF  03,50
0202E:  MOVFF  02,4F
02032:  MOVFF  01,4E
02036:  MOVFF  00,4D
0203A:  CLRF   54
0203C:  CLRF   53
0203E:  CLRF   52
02040:  MOVLW  7E
02042:  MOVWF  51
02044:  CALL   161A
02048:  MOVFF  03,4C
0204C:  MOVFF  02,4B
02050:  MOVFF  01,4A
02054:  MOVFF  00,49
02058:  CALL   13F6
0205C:  MOVF   01,W
0205E:  BRA    20CE
02060:  CLRF   4A
02062:  MOVFF  48,49
02066:  CALL   15E4
0206A:  MOVFF  03,4C
0206E:  MOVFF  02,4B
02072:  MOVFF  01,4A
02076:  MOVFF  00,49
0207A:  CLRF   50
0207C:  CLRF   4F
0207E:  CLRF   4E
02080:  MOVLW  7E
02082:  MOVWF  4D
02084:  CALL   1304
02088:  MOVFF  00,49
0208C:  MOVFF  01,4A
02090:  MOVFF  02,4B
02094:  MOVFF  03,4C
02098:  BSF    FD8.1
0209A:  MOVFF  03,50
0209E:  MOVFF  02,4F
020A2:  MOVFF  01,4E
020A6:  MOVFF  00,4D
020AA:  CLRF   54
020AC:  CLRF   53
020AE:  CLRF   52
020B0:  MOVLW  7E
020B2:  MOVWF  51
020B4:  CALL   161A
020B8:  MOVFF  03,4C
020BC:  MOVFF  02,4B
020C0:  MOVFF  01,4A
020C4:  MOVFF  00,49
020C8:  CALL   13F6
020CC:  MOVF   01,W
020CE:  ADDWF  34,F
....................  // if(precision>1) size+=(dec>=1 && precision > 1) ? (precision - round(precision*0.5))  : 0; 
....................    } 
....................    for (i = 0; i < NUM_DISPLAYS; i++){output_Displays (~D7Seg); output_bit (transistorPins[i], ~Q); } //Apaga todos los displays 
020D0:  CLRF   3B
020D2:  CLRF   3A
020D4:  MOVF   3B,F
020D6:  BNZ   2138
020D8:  MOVF   3A,W
020DA:  SUBLW  03
020DC:  BNC   2138
020DE:  MOVLW  00
020E0:  BTFSS  29.0
020E2:  MOVLW  01
020E4:  MOVWF  49
020E6:  CLRF   F95
020E8:  MOVWF  F8C
020EA:  BCF    FD8.0
020EC:  RLCF   3A,W
020EE:  MOVWF  02
020F0:  RLCF   3B,W
020F2:  MOVWF  03
020F4:  MOVF   02,W
020F6:  CALL   10BE
020FA:  TBLRD*+
020FC:  MOVFF  FF5,03
02100:  MOVWF  49
02102:  MOVFF  03,4A
02106:  MOVLW  00
02108:  BTFSS  29.1
0210A:  MOVLW  01
0210C:  MOVFF  49,4B
02110:  MOVWF  4C
02112:  MOVLW  0F
02114:  MOVWF  4E
02116:  MOVLW  89
02118:  MOVWF  4D
0211A:  CALL   1884
0211E:  MOVFF  49,4B
02122:  CLRF   4C
02124:  MOVLW  0F
02126:  MOVWF  4E
02128:  MOVLW  92
0212A:  MOVWF  4D
0212C:  CALL   1884
02130:  INCF   3A,F
02132:  BTFSC  FD8.2
02134:  INCF   3B,F
02136:  BRA    20D4
....................    time = time / ( (TIME_MUX / 1000) * size); //Calcula el numero de ciclos segun el tiempo de multiplexacion que se introdujo 
02138:  MOVFF  47,4C
0213C:  MOVFF  46,4B
02140:  CLRF   4E
02142:  MOVFF  34,4D
02146:  CALL   14BE
0214A:  MOVFF  02,47
0214E:  MOVFF  01,46
....................    if (time == 0) time = 1; //Evita que el valor sea 0 y nunca entre al bucle 
02152:  MOVF   46,F
02154:  BNZ   2160
02156:  MOVF   47,F
02158:  BNZ   2160
0215A:  CLRF   47
0215C:  MOVLW  01
0215E:  MOVWF  46
....................    for (j = 0; j < time; j++) 
02160:  CLRF   3D
02162:  CLRF   3C
02164:  MOVF   3D,W
02166:  SUBWF  47,W
02168:  BTFSS  FD8.0
0216A:  BRA    23A4
0216C:  BNZ   2176
0216E:  MOVF   46,W
02170:  SUBWF  3C,W
02172:  BTFSC  FD8.0
02174:  BRA    23A4
....................    { 
....................       if (limit) 
02176:  BTFSS  29.3
02178:  BRA    22DC
....................       { 
....................          for (i = 0; i < (size+((signo) ? 1 : 0)); i++) 
0217A:  CLRF   3B
0217C:  CLRF   3A
0217E:  BTFSS  29.2
02180:  BRA    2188
02182:  CLRF   03
02184:  MOVLW  01
02186:  BRA    218C
02188:  CLRF   03
0218A:  MOVLW  00
0218C:  ADDWF  34,W
0218E:  MOVWF  01
02190:  MOVLW  00
02192:  ADDWFC 03,F
02194:  MOVF   3B,W
02196:  SUBWF  03,W
02198:  BTFSS  FD8.0
0219A:  BRA    22DA
0219C:  BNZ   21A6
0219E:  MOVF   01,W
021A0:  SUBWF  3A,W
021A2:  BTFSC  FD8.0
021A4:  BRA    22DA
....................          { 
....................             output_bit (transistorPins[i], Q); //Satura el transistor dependiendo si son PNP o NPN 
021A6:  BCF    FD8.0
021A8:  RLCF   3A,W
021AA:  MOVWF  02
021AC:  RLCF   3B,W
021AE:  MOVWF  03
021B0:  MOVF   02,W
021B2:  CALL   10BE
021B6:  TBLRD*+
021B8:  MOVFF  FF5,03
021BC:  MOVWF  49
021BE:  MOVFF  03,4A
021C2:  MOVLW  00
021C4:  BTFSC  29.1
021C6:  MOVLW  01
021C8:  MOVFF  49,4B
021CC:  MOVWF  4C
021CE:  MOVLW  0F
021D0:  MOVWF  4E
021D2:  MOVLW  89
021D4:  MOVWF  4D
021D6:  CALL   1884
021DA:  MOVFF  49,4B
021DE:  CLRF   4C
021E0:  MOVLW  0F
021E2:  MOVWF  4E
021E4:  MOVLW  92
021E6:  MOVWF  4D
021E8:  CALL   1884
....................             if (i == (size) && signo){temp = 0b01000000; } //Asigna el signo 
021EC:  MOVF   34,W
021EE:  SUBWF  3A,W
021F0:  BNZ   2206
021F2:  MOVF   3B,F
021F4:  BNZ   2206
021F6:  BTFSS  29.2
021F8:  BRA    2206
021FA:  CLRF   39
021FC:  CLRF   38
021FE:  CLRF   37
02200:  MOVLW  40
02202:  MOVWF  36
....................             else{ temp = tabla7Seg[digito[i]] | ( (i == precision && precision > 0) ? 0b10000000 : 0); } // escoge el numero y añade el punto si es necesario 
02204:  BRA    2250
02206:  MOVLW  30
02208:  ADDWF  3A,W
0220A:  MOVWF  FE9
0220C:  MOVLW  00
0220E:  ADDWFC 3B,W
02210:  MOVWF  FEA
02212:  CLRF   03
02214:  MOVF   FEF,W
02216:  CALL   10DA
0221A:  MOVWF  49
0221C:  MOVF   48,W
0221E:  SUBWF  3A,W
02220:  BNZ   2236
02222:  MOVF   3B,F
02224:  BNZ   2236
02226:  MOVF   48,F
02228:  BZ    2236
0222A:  MOVLW  80
0222C:  MOVWF  00
0222E:  CLRF   01
02230:  CLRF   02
02232:  CLRF   03
02234:  BRA    223E
02236:  CLRF   00
02238:  CLRF   01
0223A:  CLRF   02
0223C:  CLRF   03
0223E:  MOVF   00,W
02240:  IORWF  49,W
02242:  MOVWF  36
02244:  MOVFF  01,37
02248:  MOVFF  02,38
0224C:  MOVFF  03,39
....................             output_Displays ( ( (D7Seg) ? temp : ~ (temp))); //Activa la salida dependiendo si es de anodo o catodo comun los displays 
02250:  BTFSS  29.0
02252:  BRA    2266
02254:  MOVFF  36,00
02258:  MOVFF  37,01
0225C:  MOVFF  38,02
02260:  MOVFF  39,03
02264:  BRA    227E
02266:  MOVFF  36,00
0226A:  COMF   00,F
0226C:  MOVFF  37,01
02270:  COMF   01,F
02272:  MOVFF  38,02
02276:  COMF   02,F
02278:  MOVFF  39,03
0227C:  COMF   03,F
0227E:  CLRF   F95
02280:  MOVFF  00,F8C
....................             delay_us (TIME_MUX); 
02284:  MOVLW  01
02286:  MOVWF  49
02288:  CALL   18C2
....................             output_bit (transistorPins[i], ~Q) ;//Apaga el transistor 
0228C:  BCF    FD8.0
0228E:  RLCF   3A,W
02290:  MOVWF  02
02292:  RLCF   3B,W
02294:  MOVWF  03
02296:  MOVF   02,W
02298:  CALL   10BE
0229C:  TBLRD*+
0229E:  MOVFF  FF5,03
022A2:  MOVWF  49
022A4:  MOVFF  03,4A
022A8:  MOVLW  00
022AA:  BTFSS  29.1
022AC:  MOVLW  01
022AE:  MOVFF  49,4B
022B2:  MOVWF  4C
022B4:  MOVLW  0F
022B6:  MOVWF  4E
022B8:  MOVLW  89
022BA:  MOVWF  4D
022BC:  CALL   1884
022C0:  MOVFF  49,4B
022C4:  CLRF   4C
022C6:  MOVLW  0F
022C8:  MOVWF  4E
022CA:  MOVLW  92
022CC:  MOVWF  4D
022CE:  CALL   1884
....................          } 
022D2:  INCF   3A,F
022D4:  BTFSC  FD8.2
022D6:  INCF   3B,F
022D8:  BRA    217E
....................  
....................          }else{ 
022DA:  BRA    239C
....................          time=1; 
022DC:  CLRF   47
022DE:  MOVLW  01
022E0:  MOVWF  46
....................          for (i = 0; i < NUM_DISPLAYS; i++) //Indicador que el numero ingresado es mayor de lo permitido 
022E2:  CLRF   3B
022E4:  CLRF   3A
022E6:  MOVF   3B,F
022E8:  BNZ   239C
022EA:  MOVF   3A,W
022EC:  SUBLW  03
022EE:  BNC   239C
....................          { 
....................             output_bit (transistorPins[i], Q) ; 
022F0:  BCF    FD8.0
022F2:  RLCF   3A,W
022F4:  MOVWF  02
022F6:  RLCF   3B,W
022F8:  MOVWF  03
022FA:  MOVF   02,W
022FC:  CALL   10BE
02300:  TBLRD*+
02302:  MOVFF  FF5,03
02306:  MOVWF  49
02308:  MOVFF  03,4A
0230C:  MOVLW  00
0230E:  BTFSC  29.1
02310:  MOVLW  01
02312:  MOVFF  49,4B
02316:  MOVWF  4C
02318:  MOVLW  0F
0231A:  MOVWF  4E
0231C:  MOVLW  89
0231E:  MOVWF  4D
02320:  CALL   1884
02324:  MOVFF  49,4B
02328:  CLRF   4C
0232A:  MOVLW  0F
0232C:  MOVWF  4E
0232E:  MOVLW  92
02330:  MOVWF  4D
02332:  CALL   1884
....................             output_Displays ( ( (D7Seg) ? 0b01000000 : ~0b01000000)); 
02336:  BTFSS  29.0
02338:  BRA    2340
0233A:  CLRF   03
0233C:  MOVLW  40
0233E:  BRA    2342
02340:  MOVLW  BF
02342:  CLRF   F95
02344:  MOVWF  F8C
....................             delay_us (TIME_MUX) ; 
02346:  MOVLW  01
02348:  MOVWF  49
0234A:  CALL   18C2
....................             output_bit (transistorPins[i], ~Q) ; 
0234E:  BCF    FD8.0
02350:  RLCF   3A,W
02352:  MOVWF  02
02354:  RLCF   3B,W
02356:  MOVWF  03
02358:  MOVF   02,W
0235A:  CALL   10BE
0235E:  TBLRD*+
02360:  MOVFF  FF5,03
02364:  MOVWF  49
02366:  MOVFF  03,4A
0236A:  MOVLW  00
0236C:  BTFSS  29.1
0236E:  MOVLW  01
02370:  MOVFF  49,4B
02374:  MOVWF  4C
02376:  MOVLW  0F
02378:  MOVWF  4E
0237A:  MOVLW  89
0237C:  MOVWF  4D
0237E:  CALL   1884
02382:  MOVFF  49,4B
02386:  CLRF   4C
02388:  MOVLW  0F
0238A:  MOVWF  4E
0238C:  MOVLW  92
0238E:  MOVWF  4D
02390:  CALL   1884
....................          } 
02394:  INCF   3A,F
02396:  BTFSC  FD8.2
02398:  INCF   3B,F
0239A:  BRA    22E6
....................       } 
....................    } 
0239C:  INCF   3C,F
0239E:  BTFSC  FD8.2
023A0:  INCF   3D,F
023A2:  BRA    2164
.................... } 
023A4:  GOTO   2474 (RETURN)
....................  

Configuration Fuses:
   Word  1: F79A   NOWDT PLL3 NOPLLEN NOSTVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: FF3D   HSPLL SOSC_HIGH CLOCKOUT NOFCMEN NOIESO WDT32768
   Word  3: F861   DSWDTOSC_INT RTCOSC_INT NODSBOR NODSWDT DSWDT8192 NOIOL1WAY ADC12 MSSPMSK7
   Word  4: F980   NOWPFP NOWPCFG WPDIS WPEND LS48MHZ
